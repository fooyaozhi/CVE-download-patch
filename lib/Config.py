#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Config reader to read the configuration file
#

# imports
import os
# import redis
# import ssl

# import bz2
import configparser
# import datetime
# import gzip
# import pytz
# import re
# import urllib.request as req
# import zipfile
# from io import BytesIO

runPath = os.path.dirname(os.path.realpath(__file__))
# spark cluster config file reading format
# import sys
# sys.path.append('overall_pypi_dep')
# import pkgutil
# import io


class Configuration():
    # spark_cluster mode
    # data = pkgutil.get_data('config', "configuration.ini").decode()
    # buf = io.StringIO(data)
    ConfigParser = configparser.ConfigParser()
    # ConfigParser.read_file(buf)
    ConfigParser.read(os.path.join(runPath, '../config/configuration.ini'))
    default = {'redisHost': 'localhost', 'redisPort': 6379,
               'redisVendorDB': 10, 'redisNotificationsDB': 11,
               'redisRefDB': 12,
               'mongoHost': 'localhost', 'mongoPort': 27019,
               'mongoDB': 'cvedb',
               'GITHUB':'GITHUB',
               'mongoUsername': '', 'mongoPassword': '',
               'postgresHost': 'localhost', 'postgresPort': '5432',
               'postgresDb': 'cvetriage',
               'postgresUsername': 'cvetriage', 'postgresPassword': '',
               'languages': {'c': 'C', 
                            'python': 'Python', 
                            'java': 'Java',
                            'javascript': 'JavaScript', 
                            'php': 'PHP',
                            'go': 'Go', 
                            'ruby': 'Ruby',
                            'closed source': "Closed Source",
                            'perl': 'Perl',
                            'scala': 'Swift',
                            'nuget': 'C#',
                            'objective-c': 'Objective-C',
                            'unsure': 'UNSURE'},

               'defaultUsername': 'datapipeline',
               'CVEStartYear': 2002,
               'maxLogSize': '100MB',
               'updatelogfile': 'Log/update.log',
               'http_proxy': ''
               }
    sources = {'cve': 'https://nvd.nist.gov/feeds/json/cve/1.1/',
               'meta': 'https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-modified.meta',
               'cpe': 'https://static.nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.2.xml',
               'cwe': 'http://cwe.mitre.org/data/xml/cwec_v2.12.xml.zip',
               'capec': 'http://capec.mitre.org/data/xml/capec_v2.6.xml',
               'via4': 'http://www.cve-search.org/feeds/via4.json',
               'includecve': True, 'includecapec': True, 'includemsbulletin': True,
               'includecpe': True, 'includecwe': True, 'includevia4': True
               }

    @classmethod
    def readSetting(cls, section, item, default):
        result = default
        try:
            if type(default) == bool:
                result = cls.ConfigParser.getboolean(section, item)
            elif type(default) == int:
                result = cls.ConfigParser.getint(section, item)
            else:
                result = cls.ConfigParser.get(section, item)
        except:
            pass
        return result

    # # Mongo
    # @classmethod
    # def getMongoConnection(cls):
    #     mongoUser = cls.readSetting(
    #         'Mongo', 'MONGO_INITDB_ROOT_USERNAME', cls.default['mongoUsername'])
    #     mongoPass = cls.readSetting(
    #         'Mongo', 'MONGO_INITDB_ROOT_PASSWORD', cls.default['mongoPassword'])
    #     mongoDb = cls.readSetting(
    #         'Mongo', 'MONGO_DB_NAME', cls.default['mongoDB'])
    #     mongoHost = cls.readSetting(
    #         'Mongo', 'MONGODB_HOST', cls.default['mongoHost'])
    #     mongoPort = cls.readSetting(
    #         'Mongo', 'MONGODB_PORT', cls.default['mongoPort'])

    #     return mongoUser, mongoPass, mongoDb, mongoHost, mongoPort

    @classmethod
    def getGITHUB(cls):
        GITHUB = cls.readSetting(
            'GITHUB', 'GITHUB', cls.default['GITHUB'])
        return GITHUB

    @classmethod
    def getStdoutSettings(cls):
        DEBUG = cls.readSetting(
            'StdoutSettings', 'DEBUG', False)
        VERBOSE = cls.readSetting(
            'StdoutSettings', 'VERBOSE', False)
        return DEBUG, VERBOSE
        
    # Postgres
    @classmethod
    def getPostgresConnection(cls):
        postgresDb = cls.readSetting(
            'Postgres', 'DB', cls.default['postgresDb'])
        postgresHost = cls.readSetting(
            'Postgres', 'Host', cls.default['postgresHost'])
        postgresPort = cls.readSetting(
            'Postgres', 'Port', cls.default['postgresPort'])
        postgresUser = cls.readSetting(
            'Postgres', 'User', cls.default['postgresUsername'])
        postgresPwd = cls.readSetting(
            'Postgres', 'Password', cls.default['postgresPassword'])
        return postgresDb, postgresHost, postgresPort, postgresUser, postgresPwd

    # # Redis
    # @classmethod
    # def getRedisHost(cls):
    #     return cls.readSetting('Redis', 'Host', cls.default['redisHost'])

    # @classmethod
    # def getRedisPort(cls):
    #     return cls.readSetting('Redis', 'Port', cls.default['redisPort'])

    # @classmethod
    # def getRedisVendorConnection(cls):
    #     redisHost = cls.getRedisHost()
    #     redisPort = cls.getRedisPort()
    #     redisDB = cls.readSetting(
    #         'Redis', 'VendorsDB', cls.default['redisVendorDB'])
    #     return redis.StrictRedis(host=redisHost, port=redisPort, db=redisDB, charset='utf-8', decode_responses=True)

    # @classmethod
    # def getRedisNotificationsConnection(cls):
    #     redisHost = cls.getRedisHost()
    #     redisPort = cls.getRedisPort()
    #     redisDB = cls.readSetting(
    #         'Redis', 'NotificationsDB', cls.default['redisNotificationsDB'])
    #     return redis.StrictRedis(host=redisHost, port=redisPort, db=redisDB, charset='utf-8', decode_responses=True)

    # @classmethod
    # def getRedisRefConnection(cls):
    #     redisHost = cls.getRedisHost()
    #     redisPort = cls.getRedisPort()
    #     redisDB = cls.readSetting('Redis', 'RefDB', cls.default['redisRefDB'])
    #     return redis.StrictRedis(host=redisHost, port=redisPort, db=redisDB, charset='utf-8', decode_responses=True)

    # # Http Proxy
    # @classmethod
    # def getProxy(cls):
    #     return cls.readSetting('Proxy', 'http', cls.default['http_proxy'])

    # # CVE
    # @classmethod
    # def getCVEStartYear(cls):
    #     date = datetime.datetime.now(pytz.utc)
    #     year = date.year + 1
    #     score = cls.readSetting(
    #         'CVE', 'StartYear', cls.default['CVEStartYear'])
    #     if score < 2002 or score > year:
    #         print('The year %i is not a valid year.\ndefault year %i will be used.' % (
    #             score, cls.default['CVEStartYear']))
    #         score = cls.default['CVEStartYear']
    #     return cls.readSetting('CVE', 'StartYear', cls.default['CVEStartYear'])

    # @classmethod
    # def getLanguageNameMapping(cls):
    #     return cls.readSetting('CVE', 'LanguageMapping', cls.default['languages'])

    # @classmethod
    # def getDefaultUser(cls):
    #     return cls.readSetting('default', 'Username', cls.default['defaultUsername'])

    # # Logging
    # @classmethod
    # def toPath(cls, path):
    #     return path if os.path.isabs(path) else os.path.join(runPath, '..', path)

    # @classmethod
    # def getUpdateLogFile(cls):
    #     logfile_directory = cls.toPath('Log')
    #     if not os.path.exists(logfile_directory):
    #         os.mkdir(logfile_directory)

    #     logfile = cls.toPath(cls.readSetting(
    #         'Logging', 'Updatelogfile', cls.default['updatelogfile']))
    #     logfile_latest = logfile.replace('.log',
    #                                      datetime.datetime.now(pytz.utc).strftime("_%Y_%m_%d.log"))
    #     return logfile_latest

    # @classmethod
    # def getMaxLogSize(cls):
    #     size = cls.readSetting('Logging', 'MaxSize', cls.default['maxLogSize'])
    #     split = re.findall('\d+|\D+', size)
    #     try:
    #         if len(split) > 2 or len(split) == 0:
    #             raise Exception
    #         base = int(split[0])
    #         if len(split) == 1:
    #             multiplier = 1
    #         else:
    #             multiplier = (split[1]).strip().lower()
    #             if multiplier == 'b':
    #                 multiplier = 1
    #             elif multiplier == 'kb':
    #                 multiplier = 1024
    #             elif multiplier == 'mb':
    #                 multiplier = 1024 * 1024
    #             elif multiplier == 'gb':
    #                 multiplier = 1024 * 1024 * 1024
    #             else:
    #                 # If we cannot interpret the multiplier, we take MB as default
    #                 multiplier = 1024 * 1024
    #         return base * multiplier
    #     except Exception as e:
    #         print(e)
    #         return 100 * 1024

    # @classmethod
    # def getFile(cls, getfile, unpack=True):
    #     if cls.getProxy():
    #         proxy = req.ProxyHandler(
    #             {'http': cls.getProxy(), 'https': cls.getProxy()})
    #         auth = req.HTTPBasicAuthHandler()
    #         opener = req.build_opener(proxy, auth, req.HTTPHandler)
    #         req.install_opener(opener)
    #     response = req.urlopen(
    #         getfile, context=ssl._create_unverified_context())
    #     data = response
    #     # TODO: if data == text/plain; charset=utf-8, read and decode
    #     if unpack:
    #         print(getfile, response.info().get('Content-Type'))
    #         if 'gzip' in response.info().get('Content-Type'):
    #             buf = BytesIO(response.read())
    #             data = gzip.GzipFile(fileobj=buf)
    #         elif 'bzip2' in response.info().get('Content-Type'):
    #             data = BytesIO(bz2.decompress(response.read()))
    #         elif 'zip' in response.info().get('Content-Type'):
    #             fzip = zipfile.ZipFile(BytesIO(response.read()), 'r')
    #             if len(fzip.namelist()) > 0:
    #                 data = BytesIO(fzip.read(fzip.namelist()[0]))
    #     return (data, response)

    # # Feeds
    # @classmethod
    # def getFeedData(cls, source, unpack=True):
    #     source = cls.getFeedURL(source)
    #     return cls.getFile(source, unpack) if source else None

    # @classmethod
    # def getFeedURL(cls, source):
    #     cls.ConfigParser.clear()
    #     cls.ConfigParser.read(os.path.join(runPath, '../etc/sources.ini'))
    #     return cls.readSetting('Sources', source, cls.sources.get(source, ''))

    # @classmethod
    # def includesFeed(cls, feed):
    #     return cls.readSetting('EnabledFeeds', feed, cls.sources.get('include' + feed, False))

    # # Mongo
    # @classmethod
    # def getSpark(cls):
    #     start = cls.readSetting(
    #         'Spark', 'Start', '')
    #     stop = cls.readSetting(
    #         'Spark', 'Stop', '')
    #     key = cls.readSetting(
    #         'Spark', 'Key', '')
    #     secret = cls.readSetting(
    #         'Spark', 'Secret', '')
    #     header = cls.readSetting(
    #         'Spark', 'Headers', '')
    #     ip = cls.readSetting(
    #         'Spark', 'IP', '')      
