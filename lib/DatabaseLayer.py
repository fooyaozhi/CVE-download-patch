#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Database layer
#  translates database calls to functions


# Imports
# import pymongo
import sys
# import urllib.parse
from collections import defaultdict
from datetime import datetime, timedelta

from sqlalchemy import create_engine, and_, or_, not_
from sqlalchemy.orm import scoped_session, sessionmaker, load_only, Load
from sqlalchemy.orm import defer

from lib.Constants import PatchParserStatus
import lib.DatabaseModels as models


# class MongoDb():
#     COLLECTION_DICT = {
#         'cve': 'cves',
#         'cpe': 'cpes',
#         'cwe': 'cwe',
#         'cpeother': 'cpeother',
#         'whitelist': 'mgmt_whitelist',
#         'blacklist': 'mgmt_blacklist',
#         'users': 'mgmt_users',
#         'info': 'info',
#         'ranking': 'ranking',
#         'via4': 'via4',
#         'capec': 'capec',
#         'plugin_settings': 'plugin_settings',
#         'plugin_user_settings': 'plugin_user_settings'
#     }

#     def __init__(self, mongo_user, mongo_password, mongo_db, mongo_host, mongo_port):
#         # Connect to the database
#         try:
#             c_user = urllib.parse.quote_plus(mongo_user)
#             c_pwd = urllib.parse.quote_plus(mongo_password)
#             connect = pymongo.MongoClient(f'mongodb://{c_user}:{c_pwd}@{mongo_host}:{mongo_port}', connect=False)

#         except:
#             sys.exit(f'Unable to connect to Mongo. Is it running on {mongo_host}:{mongo_port}? or User: {mongo_user}, Password: {mongo_password} correct ?')
#         self.db = connect[mongo_db]
    
#     @classmethod
#     def sanitize(cls, x):
#         if type(x) == pymongo.cursor.Cursor:
#             x = list(x)
#         if type(x) == list:
#             for y in x: cls.sanitize(y)
#         if x and  '_id' in x: x.pop('_id')
#         return x

#     def get_collection_name(self, col_key):
#         collection_name = 'unknown'
#         try:
#             collection_name = self.__class__.COLLECTION_DICT[col_key]
#         except:
#             print (f'Unknown collection key: {col_key}')
#         return collection_name

#     def get_collection(self, col_key):
#         collection_name = self.get_collection_name(col_key)
#         return self.db[collection_name]

#     def get_all_collection_names(self):
#         return self.db.collection_names()

#     @staticmethod
#     def get_field(record, field_name):
#         if record and field_name in record:
#             return record[field_name]
#         return None

#     def get_info_value(self, col_key, field):
#         info_col = self.get_collection('info')
#         collection_name = self.get_collection_name(col_key)
#         info = self.sanitize(info_col.find_one({'db': collection_name}))
#         return self.get_field(info, field)

#     def get_cves(self, limit=False, query=[], skip=0):
#         col = self.get_collection('cve')
#         if type(query) == dict:
#             query = [query]
#         if not len(query):
#             cve = col.find().limit(limit).skip(skip)
#         elif len(query) == 1:
#             cve = col.find(query[0]).limit(limit).skip(skip)
#         else:
#             cve = col.find({'$and': query}).limit(limit).skip(skip)
#         return self.sanitize(cve)

#     def get_cves_modified_after(self, modified_date=None):
#         query = []
#         if modified_date:
#             query = {'mongodb-modification': {'$gt': modified_date}}
#         return self.get_cves(query=query)

#     def get_cve(self, id):
#         col = self.get_collection('cve')
#         return self.sanitize(col.find_one({'id': id}))

#     def get_cpe(self, id):
#         col = self.get_collection('cpe')
#         return self.sanitize(col.find_one({'id': id}))

#     def get_cve_cpe_map(self):
#         cve_key = 'vulnerable_configuration_cpe_2_2'
#         cves = self.get_cves()
#         cpe_map = {}

#         for cve in cves:
#             if cve_key in cve:
#                 cpe_map[cve['id']] = cve[cve_key]
#             else:
#                 cpe_map[cve['id']] = []
#         return cpe_map

#     def get_alternative_cpe(self, id):
#         collection = self.get_collection('cpeother')
#         return self.sanitize(collection.find_one({'id': id}))

#     def get_last_modified(self, col_key):
#         return self.get_info_value(col_key, 'last-modified')

#     def get_last_processed(self, col_key):
#         return self.get_info_value(col_key, 'last-processed')

#     def get_size(self, col_key):
#         col = self.get_collection(col_key)
#         return col.count()

#     # Setters
#     def set_info(self, col_key, field, data):
#         info_col = self.get_collection('info')
#         collection_name = self.get_collection_name(col_key)             
#         info_col.update({'db': collection_name}, {'$set': {field: data}}, upsert=True)

#     def set_last_modified(self, col_key, date):
#         self.set_info(col_key, 'last-modified', date)

#     def set_last_processed(self, col_key, date):
#         self.set_info(col_key, 'last-processed', date)

#     def insert_cve(self, cve):
#         cve_col = self.get_collection('cve')
#         cve_col.insert(cve)

#     def update_cve(self, cve):
#         # Update every field other than the id
#         update_object = {}
#         for key in cve:
#             if key == 'id':
#                 continue
#             update_object[key] = cve[key]
#         # Update
#         cve_col = self.get_collection('cve')
#         cve_col.update({'id': cve['id']}, {'$set': update_object})

#     def bulk_update(self, collection, data):
#         if len(data) > 0:
#             col = self.get_collection(collection)
#             bulk = col.initialize_unordered_bulk_op()
#             for x in data:
#                 bulk.find({'id': x['id']}).upsert().update({'$set': x})
#             bulk.execute()

#     def bulk_insert_cpeother(self, cpeother_list):
#         cpeother_col = self.get_collection('cpeother')
#         cpeother_col.insert(cpeother_list)

#     def drop_collection(self, col):
#         collection = self.get_collection(col)
#         return collection.drop()


class PostgresDb():
    TABLE_OBJECTS = {
        'vulnerability': models.Vulnerability(),
        'cvssv2': models.CvssV2(),
        'cvssv3': models.CvssV3(),
        'language': models.Language(),
        'patch': models.Patch(),
        'patchhunk': models.PatchHunk(),
        'patch_source': models.PatchSource(),
        'vulnerability_language': models.VulnerabilityLanguage(),
        'vulnerability_language_prediction': models.VulnerabilityLanguagePrediction(),
        'vulnerability_library': models.VulnerabilityLibrary(),
        'vulnerability_library_version': models.VulnerabilityLibraryVersion(),
        'vulnerability_library_prediction': models.VulnerabilityLibraryPrediction(),
        'scantist_cvssv2': models.ScantistCvssv2(),
        'scantist_cvssv3': models.ScantistCvssv3(),
        'scantist_security_issue': models.ScantistSecurityissue(),
        'scantist_vulnerability': models.ScantistVulnerability(),
        'scantist_patch': models.ScantistPatch(),
        'scantist_patchhunk': models.ScantistPatchhunk(),
        'scantist_libraryversionissue': models.ScantistLibraryversionissue(),
        'scantist_missing_library_version': models.MissingLibraryVersion(),
        'scantist_cwe': models.ScantistCWE(),
        'scantist_monitor': models.ScantistMonitor(),
        'scantist_library': models.ScantistLibrary()
    }

    def __init__(self, dbname, host, port, username, password):
        try:
            url = f'postgresql://{username}:{password}@{host}:{port}/{dbname}'
            engine = create_engine(url, client_encoding='utf8')
            engine.connect()
        except:
            sys.exit('Unable to connect to PostgresDb. Is it running on %s:%s?' % (host, port))
        self.db = scoped_session(sessionmaker(bind=engine))
        self.session = self.db()

    def get_temp_object(self, table):
        return self.__class__.TABLE_OBJECTS[table]

    def get_cve_public_ids(self):
        cves = self.session.query(models.Vulnerability).all()
        return [cve.public_id for cve in cves]

    def get_cve_public_ids_no_patch(self):
        cves = self.session.query(models.Vulnerability)
        filtered_cves = cves.filter(models.Vulnerability.is_patch_available!=True)
        return [cve.public_id for cve in filtered_cves]

    def get_cves_unprocessed(self):
        seven_days_ago = datetime.now() - timedelta(days=2)
        cves = self.session.query(models.Vulnerability.id,
                models.Vulnerability.public_id).filter(or_(
                    models.Vulnerability.modified > seven_days_ago,
                    models.Vulnerability.is_valid!=True))
        return {cve[1]: cve[0] for cve in cves}

    def get_language_cve_public_ids(self, language_id):
        # Returns a list of cve public ids with language prediction =
        # language id but no language confirmation
        mappings = self.session.query(
                    models.VulnerabilityLanguagePrediction).filter(
                    models.VulnerabilityLanguagePrediction.language_id==language_id)
        cve_id_list = [m.vulnerability_id for m in mappings]
        vulnerabilities = self.session.query(
                            models.Vulnerability).filter(
                            models.Vulnerability.id.in_(cve_id_list))
        return [v.public_id for v in vulnerabilities]

    def get_cveid_extra_dict(self):
        cves = self.session.query(models.Vulnerability).all()
        return {cve.id: cve.extra_data for cve in cves}
        
    def get_cveid_languageid_list(self, public_ids=None):
        language_mappings = self.session.query(models.VulnerabilityLanguage)
        if public_ids:
            cves = self.session.query(models.Vulnerability)
            filtered_cves = cves.filter(
                            models.Vulnerability.public_id.in_(public_ids))
            cve_ids = [c.id for c in filtered_cves]
            language_mappings = language_mappings.filter(
                                models.VulnerabilityLanguage.vulnerability_id.in_(
                                cve_ids))
        return [(m.vulnerability_id, m.language_id) for m in language_mappings.all()]

    def get_confirmed_languages(self, vulnerability_ids=None):
        languages = self.session.query(
                        models.VulnerabilityLanguage.language_id,
                        models.VulnerabilityLanguage.vulnerability_id)
        if vulnerability_ids:
            languages = languages.filter(
                        models.VulnerabilityLanguage.vulnerability_id.in_(
                        vulnerability_ids))
        # Create a dict of vulnerability_id and language_id
        cve_language_map = defaultdict(list)
        for lang in languages:
            cve_language_map[lang[1]].append(lang[0])
        return dict(cve_language_map)

    def get_predicted_languages(self, vulnerability_ids=None):
        languages = self.session.query(
                        models.VulnerabilityLanguagePrediction.language_id,
                        models.VulnerabilityLanguagePrediction.vulnerability_id)
        if vulnerability_ids:
            languages = languages.filter(
                        models.VulnerabilityLanguagePrediction.vulnerability_id.in_(
                        vulnerability_ids))
        # Create a dict of vulnerability_id and language_id
        cve_language_map = defaultdict(list)
        for lang in languages:
            cve_language_map[lang[1]].append(lang[0])
        return dict(cve_language_map)

    def get_language_id_dict(self):
        languages = self.session.query(models.Language).all()
        return {l.name: l.id for l in languages}

    def get_cve_id_dict(self):
        cves = self.session.query(models.Vulnerability.public_id,
                models.Vulnerability.id).all()
        return {cve[0]: cve[1] for cve in cves}

    def get_cve_id_inv_dict(self):
        cves = self.session.query(models.Vulnerability).all()
        return {cve.id: cve.public_id for cve in cves}

    def get_cve_id_cvssv2_id_dict(self):
        cvssv2_records = self.session.query(models.CvssV2).all()
        return {c.vulnerability_id: c.id for c in cvssv2_records}

    def get_cve_id_cvssv3_id_dict(self):
        cvssv3_records = self.session.query(models.CvssV3).all()
        return {c.vulnerability_id: c.id for c in cvssv3_records}

    def get_cves_for_update(self):
        cves = self.session.query(models.Vulnerability).filter(models.Vulnerability.is_valid==True)
        cves = cves.filter(
                or_(models.Vulnerability.processed_time<models.Vulnerability.modified,
                models.Vulnerability.processed_time==None))
        return {c.id: c for c in cves}

    def get_cvssv2_for_update(self):
        cvss = self.session.query(models.CvssV2).filter(models.CvssV2.is_valid==True)
        cvss = cvss.filter(
                or_(models.CvssV2.processed_time<models.CvssV2.modified,
                models.CvssV2.processed_time==None))
        return {c.vulnerability_id: c for c in cvss}

    def get_cvssv3_for_update(self):
        cvss = self.session.query(models.CvssV3).filter(models.CvssV3.is_valid==True)
        cvss = cvss.filter(
                or_(models.CvssV3.processed_time<models.CvssV3.modified,
                models.CvssV3.processed_time==None))
        return {c.vulnerability_id: c for c in cvss}

    def get_lib_name_id_dict_by_platform(self, platform):
        libs = self.session.query(models.ScantistLibrary.name, models.ScantistLibrary.id)\
            .filter(models.ScantistLibrary.is_valid==True)\
            .filter(models.ScantistLibrary.platform==platform).all()
        return {lib[0]: lib[1] for lib in libs}

    def get_mapped_cve_lib_ver(self):
        vul_mapping = {}
        vul_lib_vers = self.session.query(models.VulnerabilityLibrary.vulnerability_id,
                                  models.ScantistLibrary.name, models.VulnerabilityLibrary.version_ranges)\
            .filter(models.ScantistLibrary.id==models.VulnerabilityLibrary.library_id)\
            .filter(models.ScantistLibrary.is_valid==True)\
            .filter(models.VulnerabilityLibrary.is_valid==True)\
            .filter(models.VulnerabilityLibrary.confirmed==True)\
            .filter(models.VulnerabilityLibrary.submitted_by_id!=None).all()
        for vul_lib_ver in vul_lib_vers:
            vul_mapping.setdefault(vul_lib_ver[0], {})[vul_lib_ver[1]] = vul_lib_ver[2]
        return vul_mapping

    def get_processed_cves(self, platform):
        processed_cves = set()
        cves = self.session.query(models.Vulnerability.public_id) \
            .filter(models.ScantistLibrary.id == models.VulnerabilityLibrary.library_id) \
            .filter(models.Vulnerability.id == models.VulnerabilityLibrary.vulnerability_id)\
            .filter(models.ScantistLibrary.platform == platform) \
            .filter(models.VulnerabilityLibrary.is_valid == True).all()
        for cve in cves:
            processed_cves.add(cve[0])
        return processed_cves

    def get_successful_patches(self, cve_ids=None):
        # Get only those patches that have at least 1 hunk
        patchhunks = self.session.query(
                        models.PatchHunk.patch_id).distinct().all()
        patch_ids = [p[0] for p in patchhunks]
        # A patch is uniquely identified by the vulnerability_id + patch_hash
        patches = self.session.query(models.Patch).options(
                    defer('raw')).filter(
                    models.Patch.patch_status==PatchParserStatus.succ,
                    models.Patch.id.in_(patch_ids))
        if cve_ids:
            patches = patches.filter(models.Patch.vulnerability_id.in_(cve_ids))
        return patches

    def get_patches_for_update(self):
        patches = self.get_successful_patches()
        patches = patches.filter(
                or_(models.Patch.processed_time<models.Patch.modified,
                models.Patch.processed_time==None))
        return {f'{p.vulnerability_id}:{p.patch_hash}': p for p in patches}

    def get_patch_hunks_for_update(self):
        # A patchhunk can be uniquely identified by the
        # patch_id + hunk_hash + affected_file
        patch_hunks = self.session.query(models.PatchHunk).filter(
                        or_(models.PatchHunk.processed_time<models.PatchHunk.modified,
                        models.PatchHunk.processed_time==None))
        # For hunks linked to C patches, ignore those hunks not marked as c
        c_patch_ids = self.session.query(models.PatchHunk.patch_id).filter(
                        models.PatchHunk.extra_data['language'].astext == 'c'
                        ).distinct()
        c_patch_ids = list(map(lambda x: x[0], c_patch_ids.all()))
        patch_hunks = patch_hunks.filter(~and_(models.PatchHunk.patch_id.in_(c_patch_ids),
                        not_(models.PatchHunk.extra_data.has_key('language'))))
        return {f'{p.patch_id}:{p.hunk_hash}:{p.affected_file}': p for p in patch_hunks}

    def get_vulnerability_libraries_for_update(self):
        records = self.session.query(models.VulnerabilityLibrary).filter(or_(
                    models.VulnerabilityLibrary.processed_time<models.VulnerabilityLibrary.modified,
                    models.VulnerabilityLibrary.processed_time==None)
                    ).filter(models.VulnerabilityLibrary.confirmed==True)
        return records.all()

    def get_vulnerability_library_version_issue_dict(self,
                                                    library_ids=None,
                                                    cve_ids=None,
                                                    is_valid=True):
        records = self.session.query(models.VulnerabilityLibraryVersion
                    ).filter(models.VulnerabilityLibraryVersion.is_valid==is_valid)

        if library_ids:
            # Get library versions linked to library ids
            versions = self.session.query(
                        models.ScantistLibraryVersion.id).filter(
                        models.ScantistLibraryVersion.library_id.in_(library_ids))
            version_ids = [v[0] for v in versions]
            # Filter records by version ids
            records = records.filter(
                        models.VulnerabilityLibraryVersion.libraryversion_id.in_(
                        version_ids))
        if cve_ids:
            records = records.filter(
                        models.VulnerabilityLibraryVersion.vulnerability_id.in_(
                        cve_ids))

        return {f'{str(r.libraryversion_id)}:{str(r.vulnerability_id)}': r.id for r in records}

    def get_patch_id_hash_cve_id_dict(self):
        patches = self.session.query(models.Patch.id,
                    models.Patch.patch_hash,
                    models.Patch.vulnerability_id)
        return {p[0]: f'{p[1]}:{p[2]}' for p in patches}
            
    def get_libs(self, platform=None, language=None):
        libs = self.session.query(models.ScantistLibrary)
        if platform:
            libs = libs.filter(models.ScantistLibrary.platform==platform)
        if language:
            libs = libs.filter(models.ScantistLibrary.language==language)
        return libs

    def get_library_id_dict(self, platform=None, language=None):
        libs = self.get_libs(platform=platform, language=language)
        return {l.id: l for l in libs}

    def get_library_dict(self, platform=None, language=None):
        # For consistency, name and vendor are converted to
        # lower case
        libs = self.get_libs(platform=platform, language=language)
        lib_dict = {}
        for l in libs:
            vendor = l.vendor if l.vendor else ''
            lib_dict[f'{l.platform.lower()}:{vendor.lower()}:{l.name.lower()}'] = l.id
        return lib_dict

    def get_library_name_dict(self, platform=None, language=None):
        # For consistency, name is converted to lower case
        libs = self.get_libs(platform=platform, language=language)
        name_dict = defaultdict(list)
        for lib in libs:
            name_dict[lib.name.lower()].append(lib.id)
        return dict(name_dict)

    def get_library_version_dict(self,
                                    platform=None,
                                    language=None,
                                    lib_ids=None,
                                    groupby=None):
        if not lib_ids:
            libs = self.get_libs(platform=platform, language=language)
            lib_ids = [l.id for l in libs]
        lib_versions = self.session.query(models.ScantistLibraryVersion).filter(
            models.ScantistLibraryVersion.library_id.in_(lib_ids),
            models.ScantistLibraryVersion.is_valid==True)

        if groupby == 'library_id':
            version_dict = defaultdict(list)
            for v in lib_versions:
                # Version number can also be null
                if v.version_number:
                    # For consistency, all  letters are in lower case
                    # and #### is replaced by a -
                    vernum = v.version_number.replace('####', '-')
                    version_dict[v.library_id].append((vernum.lower(), v.id))
            return dict(version_dict)
        else:
            version_dict = {}
            for v in lib_versions:
                # Version number can also be null
                if v.version_number:
                    # For consistency, all special characters in the version name
                    # are replaced by - and letters are in lower case,
                    # #### replaced by a single -
                    vernum = v.version_number.replace('####', '-')
                    vernum = [e if e.isalnum() else '-' for e in vernum]
                    vernum = ''.join(vernum).lower()
                    version_dict[f'{vernum}:{v.library_id}'] = v.id
            return version_dict

    def get_libver_lib_id_dict(self):
        lib_versions = self.session.query(
                            models.ScantistLibraryVersion.id,
                            models.ScantistLibraryVersion.library_id)
        return {l[0]: l[1] for l in lib_versions}

    def get_cve_library_name_dict(self, platform=None, language=None):
        cve_dict = self.get_cve_id_inv_dict()
        lib_id_dict = self.get_library_id_dict(platform=platform,
                                                language=language)
        cve_libs = self.session.query(
                    models.VulnerabilityLibrary.vulnerability_id,
                    models.VulnerabilityLibrary.library_id).filter(
                    models.VulnerabilityLibrary.is_valid==True,
                    models.VulnerabilityLibrary.library_id.in_(
                    lib_id_dict.keys()))

        cve_lib_dict = defaultdict(list)
        for mapping in cve_libs:
            lib_name = lib_id_dict[mapping[1]].name
            cve_pubid = cve_dict[mapping[0]]
            cve_lib_dict[cve_pubid].append(lib_name.lower())
        return dict(cve_lib_dict)

    def get_cve_library_pred_dict(self, cve_ids=None):
        cve_libs = self.session.query(
                        models.VulnerabilityLibraryPrediction.vulnerability_id,
                        models.VulnerabilityLibraryPrediction.library_id)
        if cve_ids:
            cve_libs = cve_libs.filter(
                        models.VulnerabilityLibraryPrediction.vulnerability_id.in_(
                        cve_ids))
        cve_lib_id_map = defaultdict(list)
        for mapping in cve_libs:
            cve_lib_id_map[mapping[0]].append(mapping[1])
        return dict(cve_lib_id_map)

    def get_cwe_id_dict(self):
        cwes = self.session.query(models.ScantistCWE.cwe_id,
                models.ScantistCWE.id).all()
        return {cwe[0]: cwe[1] for cwe in cwes}

    def get_vulnerability_library_dict(self):
        mappings = self.session.query(models.VulnerabilityLibrary.id,
                                models.VulnerabilityLibrary.library_id,
                                models.VulnerabilityLibrary.vulnerability_id
                        ).filter(models.VulnerabilityLibrary.is_valid==True)
        return {f'{m[2]}:{m[1]}': m[0] for m in mappings}

    def get_mapped_cve_public_id_dict(self):
        library_versions = self.session.query(
                                models.VulnerabilityLibraryVersion.vulnerability_id
                            ).distinct().all()
        cve_ids = [c[0] for c in library_versions]
        cves = self.session.query(models.Vulnerability.public_id,
                models.Vulnerability.id).filter(
                models.Vulnerability.id.in_(cve_ids))
        cve_pub_id_dict = {c[0]: c[1] for c in cves}
        return cve_pub_id_dict

    def get_unprocessed_patches(self, process_failed=False):
        filters = {'patch_status': PatchParserStatus.unprocess}
        if process_failed:
            filters.update({'patch_status': PatchParserStatus.failed})
        patches = self.session.query(models.Patch).filter_by(**filters)
        return patches

    def get_patch_hash_cve_list(self):
        patches = self.session.query(models.Patch).all()
        return [(p.patch_hash, p.vulnerability_id) for p in patches]

    def get_patch_source_dict(self, vulnerability_id_list=None):
        patch_sources = self.session.query(models.PatchSource)
        if vulnerability_id_list and len(vulnerability_id_list):
            patch_sources = patch_sources.filter(
                            models.PatchSource.vulnerability_id.in_(
                            vulnerability_id_list))
        return {
            f'{s.vulnerability_id}:{s.url}': (s.id,
                s.is_patch_extracted, s.patch_hash) for s in patch_sources
        }

    def get_unique_hunk_cve_id_list(self):
        patches = self.session.query(models.Patch.id,
                    models.Patch.vulnerability_id).all()
        patch_dict = {p[0]: p[1] for p in patches}

        patch_hunks = self.session.query(
                        models.PatchHunk.patch_id,
                        models.PatchHunk.patch_code_hash,
                        models.PatchHunk.vul_code_hash,
                        models.PatchHunk.affected_file).filter(
                            models.PatchHunk.is_valid==True)
        
        # Create list of 'cve_id:affected_file:vul_code_hash:patch_code_hash'
        hunk_cve_list = []
        for hunk in patch_hunks:
            try:
                cve_id = patch_dict[hunk[0]]
                hunk_cve_list.append(f'{cve_id}:{hunk[3]}:{hunk[2]}:{hunk[1]}')
            except:
                # This case should not be encountered in practice
                pass
        return hunk_cve_list

    def get_user_id(self, username):
        try:
            user = self.session.query(models.User).filter(
                    models.User.username==username).one()
            return user.id
        except:
            return None

    def get_max_cve_id(self):
        max_id = 0
        try:
            vulns = self.session.query(models.Vulnerability).order_by(
                    models.Vulnerability.id.desc()).first()
            max_id = vulns.id
        except:
            pass
        return max_id

    # Master Tables API

    def get_master_cve_ids(self):
        cve_ids = self.session.query(
                    models.ScantistVulnerability.securityissue_ptr_id).all()
        cve_ids = [c[0] for c in cve_ids]
        return cve_ids

    def get_master_cve_public_id_dict(self):
        cve_ids = self.get_master_cve_ids()
        cves = self.session.query(
                models.ScantistSecurityissue.public_id,
                models.ScantistSecurityissue.id).filter(
                models.ScantistSecurityissue.id.in_(cve_ids))
        cve_pub_id_dict = {c[0]: c[1] for c in cves}
        return cve_pub_id_dict

    def get_master_cveid_cvssv2_dict(self):
        cve_ids = self.get_master_cve_ids()
        cvss = self.session.query(models.ScantistCvssv2.vulnerability_id,
                models.ScantistCvssv2.id).filter(
                models.ScantistCvssv2.vulnerability_id.in_(cve_ids))
        return {c[0]: c[1] for c in cvss}

    def get_master_cveid_cvssv3_dict(self):
        cve_ids = self.get_master_cve_ids()
        cvss = self.session.query(models.ScantistCvssv3.vulnerability_id,
                models.ScantistCvssv3.id).filter(
                models.ScantistCvssv3.vulnerability_id.in_(cve_ids))
        return {c[0]: c[1] for c in cvss}

    def get_master_cveid_patch_dict(self):
        # A patch is uniquely identified by the security_issue_id + patch_hash
        cve_ids = self.get_master_cve_ids()
        patches = self.session.query(
                    models.ScantistPatch.security_issue_id,
                    models.ScantistPatch.patch_hash,
                    models.ScantistPatch.id).filter(
                    models.ScantistPatch.security_issue_id.in_(cve_ids),
                    models.ScantistPatch.is_valid==True)
        return {f'{p[0]}:{p[1]}': p[2] for p in patches}

    def get_master_patchid_patchhunk_dict(self):
        # A patchhunk is uniquely identified by the (patch_id
        # + hunk_hash + affected_file)
        cve_ids = self.get_master_cve_ids()
        patches = self.session.query(
                    models.ScantistPatch.id).filter(
                    models.ScantistPatch.security_issue_id.in_(cve_ids),
                    models.ScantistPatch.is_valid==True)
        patch_ids = [p[0] for p in patches]
        patch_hunks = self.session.query(models.ScantistPatchhunk.id,
                        models.ScantistPatchhunk.patch_id,
                        models.ScantistPatchhunk.hunk_hash,
                        models.ScantistPatchhunk.affected_file).filter(
                        models.ScantistPatchhunk.patch_id.in_(patch_ids))
        return {f'{p[1]}:{p[2]}:{p[3]}': p[0] for p in patch_hunks}

    def get_max_security_issue_id(self):
        max_id = 0
        try:
            sec_issues = self.session.query(
                            models.ScantistSecurityissue).order_by(
                            models.ScantistSecurityissue.id.desc()).first()
            max_id = sec_issues.id
        except:
            pass
        return max_id

    # Setters

    def bulk_update(self, table, info_dict_list):
        tmp_object = self.get_temp_object(table)
        # Insert in chunks of 500,000 if list is too big
        chunk_size, idx = 500000, 0
        while idx < len(info_dict_list):
            min_idx = min(idx + chunk_size, len(info_dict_list))
            insert_list = info_dict_list[idx:min_idx]
            self.session.bulk_update_mappings(tmp_object, insert_list)
            idx += chunk_size
        self.session.commit()

    def bulk_insert(self, table, info_dict_list):
        tmp_object = self.get_temp_object(table)
        # Insert in chunks of 500,000 if list is too big
        chunk_size, idx = 500000, 0
        while idx < len(info_dict_list):
            min_idx = min(idx + chunk_size, len(info_dict_list))
            insert_list = info_dict_list[idx:min_idx]
            self.session.bulk_insert_mappings(tmp_object, insert_list)
            idx += chunk_size
        self.session.commit()

    def bulk_delete(self, table, delete_ids):
        tmp = self.get_temp_object(table)
        self.session.query(tmp).filter(
            tmp.id.in_(delete_ids)).delete(synchronize_session=False)
        self.session.commit()

    def reset_sequence_number(self, table):
        tmp = self.get_temp_object(table)
        table = tmp.__tablename__
        cmd = (f"SELECT setval('\"{table}_id_seq\"', " +
                f"COALESCE((SELECT MAX(id) + 1 FROM \"{table}\"), 1), FALSE);")
        self.session.execute(cmd)

    def get_cveid_language(self):
         result = (self.session.query(models.VulnerabilityLanguage)
 		.options(load_only('id', 
                             'language_id', 
                             'vulnerability_id')
                 ))
         existing_mappings = {f'{v_l.vulnerability_id}:{v_l.language_id}':  v_l.id for v_l in result}
         return existing_mappings 